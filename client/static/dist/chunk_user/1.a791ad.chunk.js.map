{"version":3,"file":"1.a791ad.chunk.js","sources":["webpack:///./node_modules/lushijie-utils/index.js","webpack:///./node_modules/lushijie-utils/node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/lushijie-utils/node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/lushijie-utils/lib/is.js","webpack:///./node_modules/lushijie-utils/lib/index.js","webpack:///./node_modules/lushijie-utils/lib/tools.js","webpack:///./node_modules/lushijie-utils/node_modules/uuid/index.js","webpack:///./node_modules/lushijie-utils/node_modules/uuid/v1.js","webpack:///./node_modules/lushijie-utils/node_modules/uuid/v4.js"],"sourcesContent":["/*\n* @Author: lushijie\n* @Date:   2017-11-25 16:19:05\n* @Last Modified by:   lushijie\n* @Last Modified time: 2017-11-25 16:41:30\n*/\nmodule.exports = require('./lib/index.js');\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","/*\n* @Author: lushijie\n* @Date:   2017-11-25 16:20:55\n* @Last Modified by:   lushijie\n* @Last Modified time: 2017-12-15 19:02:17\n*/\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\nmodule.exports = {\n  isNull(arg) {\n    return arg === null;\n  },\n\n  isUndefined(arg) {\n    return arg === undefined;\n  },\n\n  isBoolean(arg) {\n    return typeof arg === 'boolean';\n  },\n\n  isNumber(arg) {\n    return typeof arg === 'number';\n  },\n\n  isString(arg) {\n    return typeof arg === 'string';\n  },\n\n  isSymbol(arg) {\n    return typeof arg === 'symbol';\n  },\n\n  isFunction(arg) {\n    return typeof arg === 'function';\n  },\n\n  isArray(arg) {\n    if (Array.isArray) {\n      return Array.isArray(arg);\n    }\n    return objectToString(arg) === '[object Array]';\n  },\n\n  isRegExp(re) {\n    return objectToString(re) === '[object RegExp]';\n  },\n\n  isObject(arg) {\n    return objectToString(arg) === '[object Object]';\n  },\n\n  isDate(d) {\n    return objectToString(d) === '[object Date]';\n  },\n\n  isError(e) {\n    return (objectToString(e) === '[object Error]' || e instanceof Error);\n  },\n\n  isNullOrUndefined(arg) {\n    return arg == null;\n  },\n\n  isBuffer(arg) {\n    return Buffer.isBuffer(arg);\n  },\n\n  isInt(value) {\n    if (isNaN(value) || module.exports.isString(value)) {\n      return false;\n    }\n    var x = parseFloat(value);\n    return (x | 0) === x;\n  },\n\n  isTrueEmpty(obj) {\n    if (obj === undefined || obj === null || obj === '') return true;\n    if (exports.isNumber(obj) && isNaN(obj)) return true;\n    return false;\n  }\n}\n","/*\n* @Author: lushijie\n* @Date:   2017-11-25 16:20:55\n* @Last Modified by:   lushijie\n* @Last Modified time: 2017-12-15 19:38:06\n*/\nconst Tools = require('./tools.js');\nconst Is = require('./is.js');\nconst Utils = Tools.extend({}, Tools, Is);\nmodule.exports = Utils;\n\n","/*\n* @Author: lushijie\n* @Date:   2017-12-15 19:04:20\n* @Last Modified by:   lushijie\n* @Last Modified time: 2018-08-10 14:13:35\n*/\nconst crypto = require('crypto');\nconst uuid = require('uuid');\nconst Is = require('./is.js');\n\nmodule.exports = {\n  trimed(data) {\n    if (Is.isString(data)) {\n      return data.trim();\n    } else if (Is.isObject(data)) {\n      for (let key in data) {\n        if (data.hasOwnProperty(key)) {\n          data[key] = module.exports.getTrimedObject(data[key]);\n        }\n      }\n      return data;\n    } else if (Is.isArray(data)) {\n      return data.map(function(ele) {\n        return module.exports.getTrimedObject(ele);\n      });\n    } else {\n      return data;\n    }\n  },\n\n  extend(target = {}, ...args) {\n    let i = 0, length = args.length, options, name, src, copy;\n    if (!target) {\n      target = Is.isArray(args[0]) ? [] : {};\n    }\n    for (; i < length; i++) {\n      options = args[i];\n      if (!options) {\n        continue;\n      }\n      for (name in options) {\n        src = target[name];\n        copy = options[name];\n        if (src && src === copy) {\n          continue;\n        }\n        if (Is.isArray(copy)) {\n          target[name] = module.exports.extend([], copy);\n        } else if (Is.isObject(copy)) {\n          target[name] = module.exports.extend(src && Is.isObject(src) ? src : {}, copy);\n        } else {\n          target[name] = copy;\n        }\n      }\n    }\n    return target;\n  },\n\n  queryURL(url, key) {\n    url = url.replace(/^[^?=]*\\?/ig, '').split('#')[0];\n    let json = {};\n    url.replace(/(^|&)([^&=]+)=([^&]*)/g, function(a, b, key, value) {\n      // untrusted data\n      try {\n        key = decodeURIComponent(key);\n      } catch (e) {}\n      try {\n        value = decodeURIComponent(value);\n      } catch (e) {}\n\n      if (!(key in json)) {\n        // regard param'name end with [] as an array param\n        json[key] = /\\[\\]$/.test(key) ? [value] : value;\n      } else if (json[key] instanceof Array) {\n        json[key].push(value);\n      } else {\n        json[key] = [json[key], value];\n      }\n    });\n    return key ? json[key] : json;\n  },\n\n  encodeURIJSON(json) {\n    let s = [];\n    for (let p in json) {\n      if (json[p] == null) {\n        // undefined null will pass\n        continue;\n      }\n      if (json[p] instanceof Array) {\n        for (let i = 0; i < json[p].length; i++) {\n          s.push(encodeURIComponent(p) + '=' + encodeURIComponent(json[p][i]));\n        }\n      } else {\n        s.push((p) + '=' + encodeURIComponent(json[p]));\n      }\n    }\n    return s.join('&');\n  },\n\n  timeTaken(callback) {\n    console.time('timeTaken');\n    const r = callback();\n    console.timeEnd('timeTaken');\n    return r;\n  },\n\n  randomNumber(min, max, isInt) {\n    if (isInt) return Math.floor(Math.random() * (max - min + 1)) + min;\n    if (!isInt) return Math.random() * (max - min) + min;\n  },\n\n  objectToPairs(obj) {\n    return Object.keys(obj).map(k => [k, obj[k]]);\n  },\n\n  roundToDigits(n, decimals = 0) {\n    return Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);\n  },\n\n  truncate(str, num) {\n    return str.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;\n  },\n\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  },\n\n  seriesPromise(ps) {\n    return ps.reduce((p, next) => p.then(next), Promise.resolve());\n  },\n\n  promisify(func) {\n    return (...args) =>\n      new Promise((resolve, reject) =>\n        func(...args, (err, result) =>\n          err ? reject(err) : resolve(result))\n      );\n  },\n\n  initializeArray(n, value = 0){\n    return Array(n).fill(value);\n  },\n\n  md5(str) {\n    return crypto.createHash('md5').update(str + '', 'utf8').digest('hex');\n  },\n\n  uuid(version) {\n    if (version === 'v1') return uuid.v1();\n    return uuid.v4();\n  }\n}\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n"],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}